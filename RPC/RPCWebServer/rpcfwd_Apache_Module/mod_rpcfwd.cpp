/* 
**  mod_rpcfwd.c -- Apache sample rpcfwd module
**  [Autogenerated via ``apxs -n rpcfwd -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_rpcfwd.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /rpcfwd in as follows:
**
**    #   apache2.conf
**    LoadModule rpcfwd_module modules/mod_rpcfwd.so
**    <Location /rpcfwd>
**    SetHandler rpcfwd
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /rpcfwd and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/rpcfwd 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_rpcfwd.c
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"

#include "SimpleSockets.h"
#include "SimpleSockets.cpp"//workaround for stupid makefile

#include <unordered_map>

static int util_read(request_rec *r, char **rbuf, size_t &length){
	int rc;
	length = 0;
	if((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)) != OK){
		 return rc;
	}
	if(ap_should_client_block(r)){
		 char argsbuffer[HUGE_STRING_LEN];
		 int rsize, len_read, rpos=0;
		 length = r->remaining;
		 *rbuf = (char*)apr_pcalloc(r->pool, length + 1);
		 while((len_read = ap_get_client_block(r, argsbuffer, sizeof(argsbuffer))) > 0){
		     if((rpos + len_read) > length){
		         rsize = length - rpos;
		     } else {
		         rsize = len_read;
		     }
		     memcpy((char*)*rbuf + rpos, argsbuffer, rsize);
		     rpos += rsize;
		 }
	}
	return rc;
}

// adds id or increments the id counter, makes ss empty
static void addId(std::unordered_map<std::string,uint32_t>& m, std::stringstream& ss){
	std::string s = ss.str();
	int32_t i = ((int32_t)s.size())-1;
	for(;i>=0;i--){
		char c = s[i];
		if(c!=' ' && c!='\t' && c!='\r' && c!='\n'){break;}
	}
	i++;//points to first trailing whitespace
	if(i!=s.size()){
		s = s.substr(0,i);
	}
	auto it = m.find(s);
	if(it==m.end()){
		m[s] = 1;
	}else{
		it->second++;
	}
	ss.str("");
}

//TODO: forward, refactor id parsing for replies
static std::unordered_map<std::string,uint32_t> findIDsAndForward(request_rec *r){
	std::unordered_map<std::string,uint32_t> res;
	int rc;
	size_t length = 0;
	if((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)) != OK){
		return res;
	}
	if(ap_should_client_block(r)){
		char argsbuffer[HUGE_STRING_LEN];
		int rsize, len_read, rpos=0;
		length = r->remaining;
		int state = 0;
		uint32_t curlyBracketCount = 0, squareBracketCount = 0;
		std::stringstream ss;
		while((len_read = ap_get_client_block(r, argsbuffer, sizeof(argsbuffer))) > 0){
			ap_rwrite(argsbuffer, len_read, r);//TODO forward
			for(uint32_t i=0; i<len_read; i++){
				char c = argsbuffer[i];
				switch(state){
					case 0:{
						switch(c){
							case '{':{
								curlyBracketCount++;
								break;
							}case '}':{
								curlyBracketCount--;
								break;
							}case '[':{
								squareBracketCount++;
								break;
							}case ']':{
								squareBracketCount--;
								break;
							}case '\"':{
								state = 1;
								break;
							}
						}
						break;
					}case 1:{
						switch(c){
							case '\"':{
								state = 0;
								break;
							}case '\\':{
								state = 2;
								break;
							}case 'i':{
								state = 3;
								break;
							}
						}
						break;
					}case 2:{
						state = 1;
						break;
					}case 3:{
						switch(c){
							case 'd':{
								state = 4;
								break;
							}case '\\':{
								state = 2;
								break;
							}default:{
								state = 1;
								break;
							}
						}
						break;
					}case 4:{
						switch(c){
							case '\"':{
								state = 5;
								break;
							}case '\\':{
								state = 2;
								break;
							}default:{
								state = 1;
								break;
							}
						}
						break;
					}case 5:{
						switch(c){
							case ' ': case '\t': case '\n': case '\r':{
								break;
							}case ':':{
								state = 6;
								break;
							}default:{
								state = 0;
								if(c=='}'){curlyBracketCount--;}
								break;
							}
						}
						break;
					}case 6:{
						switch(c){
							case ' ': case '\t': case '\n': case '\r':{
								break;
							}case ',':{
								state = 0;
								break;
							}case '}':{
								state = 0;
								curlyBracketCount--;
								break;
							}default:{
								ss << c;//id char
								state = 7;
								break;
							}
						}
						break;
					}case 7:{
						switch(c){
							case ',':{
								addId(res, ss);
								state = 0;
								break;
							}case '}':{
								addId(res, ss);
								state = 0;
								curlyBracketCount--;
								break;
							}default:{
								ss << c;
								break;
							}
						}
						break;
					}
				}
			}
		}
	}
	return res;
}

/* The sample content handler */
static int rpcfwd_handler(request_rec *r)
{
	IPv6TCPSocket s;
	if(strcmp(r->handler, "rpcfwd")){
		return DECLINED;
	}
	r->content_type = "application/json";      

	if (!r->header_only){
		ap_rputs("The sample page from mod_rpcfwd.c\n", r);
		if(r->args){ap_rprintf(r, "Your query string was: %s", r->args);}
		auto idMap = findIDsAndForward(r);
		for(auto it=idMap.begin(); it!=idMap.end(); ++it){
			ap_rprintf(r, "id %s cnt: %i\n", it->first.c_str(), it->second);
		}
//		char* buf; size_t buflen; util_read(r, &buf, buflen);
//		ap_rprintf(r, "Post data:\n%s", buf);
	}

	return OK;
}

extern "C" {

	static void rpcfwd_register_hooks(apr_pool_t *p)
	{
		 ap_hook_handler(rpcfwd_handler, NULL, NULL, APR_HOOK_MIDDLE);
	}

}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA rpcfwd_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    rpcfwd_register_hooks  /* register hooks                      */
};

